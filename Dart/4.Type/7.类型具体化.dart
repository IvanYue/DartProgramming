/**
 * 类型具体化
 * 1.对象的实现类型并不能通过调用runtimeType来获得。
 * 2.动态类型检测和强制类型转换来检验的对象是否为某个类型的成员。
 */


/**
 * 不是所有对象都有length属性
 * 
 * 强制类型转换是在运行时执行的，因此会带来运行时的消耗。
 */

/**
 * 检查模式
 * 每次发生值传递都会触发动态检查
 * 函数或方法返回结果以赋值操作时，Dart都自动执行一次动态类型检测。
 * 检查模式确保了赋值变量的动态值是变量的静态类型的成员。
 */

/**
 * 双方存在子类或者父类关系就允许赋值
 * 赋值操作中的值的正式类型必须是变量的静态类型的子类或者null
 */

/**
 * 在运行时，类型参数时具体化的。
 * 当泛型被实例化时，在运行时传递与储存的都是实际类型参数。
 */

/**
 * 可选类型应该不会影响运行时语义，但泛型的具体化肯定会影响运行时语义。
 */

/**
 * 类和代理
 * 能够为任意类型的对象定义透明代理是一种重要的特征。
 * 
 * 如果一个类声明了一个noSuchMethod(),则即使它没有完整实现接口或者接口实现成员的签名不正确，也都不会产生警告。
 * 
 * Dart中的参数默认值必须是常量，所以我们标记对象自然是编译时常量对象。
 * 
 * 如果一个类使用了@proxy 注解。即使已知它的静态上不支持某个方法，而在代码中又对类的实例访问了该方法，Dart解析器也不会发出警告。
 */